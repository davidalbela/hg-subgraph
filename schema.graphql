type Condition @entity {
  id: ID!

  oracle: Bytes!
  questionId: Bytes!
  outcomeSlotCount: Int!

  creator: Bytes!
  createTransaction: Bytes!
  creationTimestamp: BigInt!
  creationBlockNumber: BigInt

  resolved: Boolean!
  resolveTransaction: Bytes
  resolveTimestamp: BigInt
  payoutNumerators: [BigInt!]
  payoutDenominator: BigInt

  collections: [Collection!] @derivedFrom(field: "conditions")
}

type Collection @entity {
  id: ID!
  # conditions is duplicated as conditionIds
  # so that when querying the graph node,
  # the graph does not attempt to join with the other table
  # which would cause conditions to be returned
  # sorted by ID, instead of in the same order as
  # the raw field data.
  conditions: [Condition!]!
  conditionIds: [ID!]!
  indexSets: [BigInt!]!
  multiplicities: [Int!]!
}

type Position @entity {
  id: ID!
  collateralToken: Collateral!
  collection: Collection!
  # see note above about conditions/conditionIds duplication
  conditions: [Condition!]!
  conditionIds: [ID!]!
  indexSets: [BigInt!]!
  multiplicities: [Int!]!
  lifetimeValue: BigInt!
  activeValue: BigInt!
}

type UserPosition @entity {
 id: ID!
 position: Position! 
 balance: BigInt!
 user: User!
}

type User @entity {
 id: ID!
 userPositions: [UserPosition!] @derivedFrom(field: "user")
 participatedConditions: [Condition!]!
 firstParticipation: BigInt!
 lastActive: BigInt!
}

type Collateral @entity {
  id: ID!
  activeAmount: BigInt!
  splitAmount: BigInt!
  mergedAmount: BigInt!
  redeemedAmount: BigInt!
}

